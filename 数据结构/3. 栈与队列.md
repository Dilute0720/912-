## 栈

### 栈的实现

主要实现以下功能即可:

- 压栈（Push）：在栈顶添加一个元素。
- 弹栈（Pop）：移除栈顶元素并返回它。
- 窥栈（Peek）或顶部（Top）：查看栈顶元素，不移除它。

具体可以使用数组实现, 保留一个当前栈顶的位置信息即可:
```c++
class Stack {
private:
    static const int MAX_SIZE = 100;
    int stackArray[MAX_SIZE];
    int top; // 指向栈顶的索引
};
```

### 栈的应用

多级函数的调用, 表达式求值(逆波兰式), 回溯算法, 递归算法
#### 括号匹配与栈混洗

//略过不表

能够进行括号匹配的表达式就是合法的表达式, 可以进行接下来的表达式求值

#### 中缀表达式求值

核心思路: 构建两个栈, 一个用于存储数字, 一个用于存储运算符. 每当即将进入运算符栈的运算符优先级低于栈顶运算符优先级, 则可以将栈顶运算符弹出, 再将数字栈栈顶的数据弹出进行运算操作, 将计算结果返回数字栈中.

具体实现: 
- 优先级表:![[优先级表.png]]注意优先级表中对左右括号优先级的不同设定, 右括号不可能和它后面的运算符匹配, 故不需要设定任何优先级. 为了实现括号的改变优先级功能, 巧妙的给左括号设定了最高优先级, 而给右括号设定了除左括号以外的最低优先级. 这一设定的目的可以在下文中明了.
- 弹出数据的方案:![[不同优先级处理方案.png]]**(!注意图文顺序颠倒!)** 当即将入栈的运算符优先级更低的时候, 表明可以进行栈顶运算符的运算(注意一元运算符`!`需要出栈数量为1), 当优先级相等的时候 说明遇到了右括号, 此时必然有栈顶元素为左括号, 这是由**右括号运算符的优先级小于其他所有运算符导致的**, 任何左右括号之间的元素在遇到右括号的时候都能出栈进行运算. 即将入栈的运算符优先级更高的时候则可以直接入栈等待后续.

## 队列

### 队列的实现

主要实现以下功能即可:

- 入队（Enqueue）：在队尾添加一个元素。
- 出队（Dequeue）：移除队首元素并返回它。
- 前端（Front）：查看队首元素，不移除它。

具体可使用链表or循环数组来实现 相对来说使用链表不必考虑扩容的问题, 记录头指针和尾指针即可:
```c++
// 假设 ListNode 已经定义
class Queue {
private:
    struct ListNode {
        int value;
        ListNode *next;
    };
    ListNode *front, *rear;
};
```

### 队列的应用

队列常常应用于广度优先搜索（BFS）、任务调度、缓冲处理等

另外还有一种特殊的队列,不以先入队顺序出队,而是以设定好的优先级来出队, 也就是优先级队列的概念

### 优先级队列

优先级队列是一种抽象数据类型，它类似于队列，但每个元素都有一个优先级。元素出队的顺序是根据它们的优先级，而不是它们加入队列的顺序。

我们通常使用 **堆(Heap)** 的数据结构来实现优先级队列. 具体包括下列操作:

- `push`：插入一个新元素，并根据优先级调整堆。
- `pop`：移除并返回优先级最高的元素。
- `top`：查看优先级最高的元素，不移除它。

- [ ] todo: 有关堆的部分在[[树]]的章节会再次提到

会用 了解就行 没人会去手搓优先级队列的. (赞美 C++ STL.jpg)

~~ps: 谁知道呢 毕竟你无连手搓红黑树都干得出来~~

```c++
#include <queue>
#include <vector>
#include <functional>

class PriorityQueue {
private:
    std::priority_queue<int, std::vector<int>, std::greater<int>> pq;

public:
    void push(int value) {
        pq.push(value);
    }

    int pop() {
        int value = pq.top();
        pq.pop();
        return value;
    }

    int top() const {
        return pq.top();
    }

    bool isEmpty() const {
        return pq.empty();
    }
};
```

## 关于堆栈

注意 我们通常将堆栈摆在一起说,并不是这两者在**数据结构**上有很大的关联性, 而是在**操作系统层面**二者共同管理内存分配, 栈通常用于存储局部变量和函数调用的上下文，而堆用于动态内存分配。

栈的访问速度非常快，因为它是处理器的一部分，并且栈操作有专门的指令支持;处理器提供了一些专门的寄存器（如 ESP 或 RBP 在 x86 架构中）来支持栈的操作。栈依赖于特定的硬件指令，如 `PUSH`（将数据压入栈）和 `POP`（从栈中弹出数据）

堆不是由硬件直接实现的，而是由操作系统和运行时库管理的内存区域。堆用于动态内存分配，程序员可以使用 `malloc`、`free`、`new` 和 `delete` 等操作来分配和释放内存。

	