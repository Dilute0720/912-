> **前言**
> 数组允许通过下标在常数时间内找到目标对象,但中间插入则需要线性时间;链表则反之. 有没有一种数据结构可以综合其中的优点,并回避其不足呢?树会正面回答这个问题.
> 从树开始数据结构的难度开始攀升, 针对树这种数据结构的算法也变多了,这是由于从线性结构转入树结构, 我们的思维方式也将发生飞跃, 许多基本的算法也将得到更加高效地实现.
> 另一方面, 作为一种更加模拟现实的层次结构, 我们对树的学习需要系统的理解树的数学模型, 这也是和前面几种简单的基本数据结构截然不同的地方.
> 更厉害的一点在于,看似非常复杂有无限变化的树,竟然可以统一的转化成一颗最特别的二叉树,从而让无论多复杂的多叉树总能找到通解.That's crazy!
> 让我们开始吧~
## 基本概念

- **树的定义**：树是一种层次结构的数据结构，由节点（Node）组成，每个节点有零个或多个子节点，并且有一个特定的节点称为根节点（Root）。
- **节点的度**：一个节点的子节点数量称为该节点的度。
- **树的度**：树中所有节点的度的最大值。
- **叶子节点**：没有子节点的节点。
- **内部节点**：至少有一个子节点的节点。
- **树的高度**：从根节点到最远叶子节点的最长路径的边数。

在数学上, 树被抽象为一个无环连通图:
1. **无环**：不存在一个顶点序列，使得序列中的首个顶点和最后一个顶点相同，并且序列中的顶点两两不同。
2. **连通**：从任意一个顶点出发，都可以到达其他所有顶点。
具有这些性质:
- **唯一路径**：树中任意两个节点之间有且仅有一条简单路径。
- **节点数与边数**：对于一个有 𝑛n 个节点的树，边的数量总是 𝑛−1n−1。
- **根节点**：在树中，可以指定一个特殊的节点作为根节点，从而给树赋予方向性，形成有向树。
这样的数学模型里面就隐含着树的一些有趣的操作, 简单如查找节点(找到到根节点的唯一路径),复杂则有更改根节点(这是[[红黑树]]实现过程中的基本操作)等操作.

树也可以递归地定义：一个树包含一个根节点和一个或多个子树，每个子树本身也是一个树。这种递归结构是树的数学模型的核心。

## 一切的树都是二叉树

### 二叉树

二叉树是树的一种特殊形式，其中每个节点最多有两个子节点，通常被称为左子节点和右子节点。
### 特殊类型的二叉树

- **完全二叉树**：除了最后一层，每一层都被完全填满，且最后一层的节点尽可能地集中在左侧。
- **满二叉树**：除了最后一层，每一层都被完全填满，最后一层的所有节点也完全填满。
- **平衡二叉树**：任何两个子树的高度差不超过1，例如AVL树。
- **二叉搜索树**（BST）：左子树上所有节点的值小于根节点的值，右子树上所有节点的值大于根节点的值。

### N叉树的二叉树序列化(了解)

基本理论为将每一个父节点的孩子们分为"长子+兄弟", 可以认识到每一个节点都只可能有至多一个长子和一个右兄弟,或者没有长子(也就没有子节点),或者没有兄弟(遍历完了其父节点的其他子节点). 利用"长子"做子节点,"右兄弟"做右节点, 就可以将一颗N叉树转换为二叉树.

1. **定义虚拟节点**：首先定义一个虚拟节点，这个节点将作为所有叶子节点在二叉树中的右孩子。
    
2. **递归转换**：对于N叉树中的每个节点，执行以下操作：
    
    - 将当前节点作为二叉树中的一个节点。
    - 将当前节点的第一个孩子作为其左孩子。
    - 将当前节点的第二个孩子到倒数第二个孩子作为其左孩子的右孩子，递归地将它们转换为二叉树。
    - 将最后一个孩子作为当前节点的右孩子。
3. **处理叶子节点**：如果当前节点没有孩子，将其右孩子设置为虚拟节点。
    
4. **递归终止条件**：如果当前节点的所有孩子都被处理完毕，或者当前节点是叶子节点，递归终止。

算法实例:
```python
class TreeNode:
    def __init__(self, val=0, children=None):
        self.val = val
        self.children = children if children is not None else []

def convert_nary_to_binary(root):
    if not root:
        return None

    # 创建二叉树的根节点
    binary_root = TreeNode(root.val)
    # 虚拟节点
    dummy = TreeNode(-1)

    # 当前节点
    current = binary_root
    # 索引，用于遍历N叉树的子节点
    index = 0

    while index < len(root.children):
        # 将当前N叉树节点的第一个子节点作为二叉树的左孩子
        child = root.children[index]
        current.left = TreeNode(child.val)

        # 如果当前N叉树节点有多个子节点，递归地将剩余的子节点转换为二叉树
        if index + 1 < len(root.children):
            right_child = convert_nary_to_binary(root.children[index + 1:])
            # 将转换后的二叉树连接到当前节点的右孩子
            current.right = right_child

        # 移动到下一个节点
        current = current.left
        index += 1

    # 将所有叶子节点的右孩子设置为虚拟节点
    current.right = dummy

    return binary_root
```
## 树的遍历

树的遍历是对一棵树的最基本最直观最重要的算法.也是其他算法的基础.

最直观的遍历方案一共有两种: 层序遍历和前序遍历, 分别对应于广度优先和深度优先的理论

