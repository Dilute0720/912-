> **前言**
> 数组允许通过下标在常数时间内找到目标对象,但中间插入则需要线性时间;链表则反之. 有没有一种数据结构可以综合其中的优点,并回避其不足呢?树会正面回答这个问题.
> 从树开始数据结构的难度开始攀升, 针对树这种数据结构的算法也变多了,这是由于从线性结构转入树结构, 我们的思维方式也将发生飞跃, 许多基本的算法也将得到更加高效地实现.
> 另一方面, 作为一种更加模拟现实的层次结构, 我们对树的学习需要系统的理解树的数学模型, 这也是和前面几种简单的基本数据结构截然不同的地方.
> 更厉害的一点在于,看似非常复杂有无限变化的树,竟然可以统一的转化成一颗最特别的二叉树,从而让无论多复杂的多叉树总能找到通解.That's crazy!
> 让我们开始吧~
## 基本概念

- **树的定义**：树是一种层次结构的数据结构，由节点（Node）组成，每个节点有零个或多个子节点，并且有一个特定的节点称为根节点（Root）。
- **节点的度**：一个节点的子节点数量称为该节点的度。
- **树的度**：树中所有节点的度的最大值。
- **叶子节点**：没有子节点的节点。
- **内部节点**：至少有一个子节点的节点。
- **树的高度**：从根节点到最远叶子节点的最长路径的边数。

在数学上, 树被抽象为一个无环连通图:
1. **无环**：不存在一个顶点序列，使得序列中的首个顶点和最后一个顶点相同，并且序列中的顶点两两不同。
2. **连通**：从任意一个顶点出发，都可以到达其他所有顶点。
具有这些性质:
- **唯一路径**：树中任意两个节点之间有且仅有一条简单路径。
- **节点数与边数**：对于一个有 𝑛n 个节点的树，边的数量总是 𝑛−1n−1。
- **根节点**：在树中，可以指定一个特殊的节点作为根节点，从而给树赋予方向性，形成有向树。
这样的数学模型里面就隐含着树的一些有趣的操作, 简单如查找节点(找到到根节点的唯一路径),复杂则有更改根节点(这是[[红黑树]]实现过程中的基本操作)等操作.

树也可以递归地定义：一个树包含一个根节点和一个或多个子树，每个子树本身也是一个树。这种递归结构是树的数学模型的核心。

## 一切的树都是二叉树

### 二叉树

二叉树是树的一种特殊形式，其中每个节点最多有两个子节点，通常被称为左子节点和右子节点。
### 特殊类型的二叉树

- **完全二叉树**：除了最后一层，每一层都被完全填满，且最后一层的节点尽可能地集中在左侧。
- **满二叉树**：除了最后一层，每一层都被完全填满，最后一层的所有节点也完全填满。
- **平衡二叉树**：任何两个子树的高度差不超过1，例如AVL树。
- **二叉搜索树**（BST）：左子树上所有节点的值小于根节点的值，右子树上所有节点的值大于根节点的值。

### N叉树的二叉树序列化(了解)

基本理论为将每一个父节点的孩子们分为"长子+兄弟", 可以认识到每一个节点都只可能有至多一个长子和一个右兄弟,或者没有长子(也就没有子节点),或者没有兄弟(遍历完了其父节点的其他子节点). 利用"长子"做子节点,"右兄弟"做右节点, 就可以将一颗N叉树转换为二叉树.

1. **定义虚拟节点**：首先定义一个虚拟节点，这个节点将作为所有叶子节点在二叉树中的右孩子。
    
2. **递归转换**：对于N叉树中的每个节点，执行以下操作：
    
    - 将当前节点作为二叉树中的一个节点。
    - 将当前节点的第一个孩子作为其左孩子。
    - 将当前节点的第二个孩子到倒数第二个孩子作为其左孩子的右孩子，递归地将它们转换为二叉树。
    - 将最后一个孩子作为当前节点的右孩子。
3. **处理叶子节点**：如果当前节点没有孩子，将其右孩子设置为虚拟节点。
    
4. **递归终止条件**：如果当前节点的所有孩子都被处理完毕，或者当前节点是叶子节点，递归终止。

算法实例:
```python
class TreeNode:
    def __init__(self, val=0, children=None):
        self.val = val
        self.children = children if children is not None else []

def convert_nary_to_binary(root):
    if not root:
        return None

    # 创建二叉树的根节点
    binary_root = TreeNode(root.val)
    # 虚拟节点
    dummy = TreeNode(-1)

    # 当前节点
    current = binary_root
    # 索引，用于遍历N叉树的子节点
    index = 0

    while index < len(root.children):
        # 将当前N叉树节点的第一个子节点作为二叉树的左孩子
        child = root.children[index]
        current.left = TreeNode(child.val)

        # 如果当前N叉树节点有多个子节点，递归地将剩余的子节点转换为二叉树
        if index + 1 < len(root.children):
            right_child = convert_nary_to_binary(root.children[index + 1:])
            # 将转换后的二叉树连接到当前节点的右孩子
            current.right = right_child

        # 移动到下一个节点
        current = current.left
        index += 1

    # 将所有叶子节点的右孩子设置为虚拟节点
    current.right = dummy

    return binary_root
```
## 树的遍历

树的遍历是对一棵树的最基本最直观最重要的算法.也是其他算法的基础.

最直观的遍历方案一共有两种: 广度优先遍历和深度优先遍历

### 广度优先遍历

广度优先遍历也称为层序遍历. 非常直观的一层一层从根节点开始遍历整棵树.

我们可以使用队列结构来解决层序遍历问题: 每一层入队之后将已有队列全部出队并记录其children. 

```c++
void levelOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;

    std::queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        std::cout << node->val << " "; // 访问节点

        if (node->left != nullptr) q.push(node->left); // 左子节点入队
        if (node->right != nullptr) q.push(node->right); // 右子节点入队
    }
    std::cout << std::endl;
}
```

### 深度优先遍历

深度优先遍历的思路本质是回溯算法的体现.
前序遍历从根节点开始, 一路沿着左子树的方向向最深处探索, 最后遍历右子树. 顺序为根左右
中序遍历沿着最左侧的道路一路到底,然后回溯到上一个parent,再遍历完tree(parent)."左根右"
后序遍历也是沿着最左侧到底, 从最底层的子树开始遍历,不同的是顺序为左右根.
回溯的实现可以依靠"栈"或者递归调用来实现.

#### 前序遍历

- **遍历顺序**：根节点 -> 左子树 -> 右子树
- **特点**：首先访问根节点，然后递归地进行左子树的遍历，最后是右子树。
- **适用场景**：
    - 需要快速访问树的根节点时。
    - 构建树的前序序列，例如在树结构的序列化和反序列化中。
    - 需要根据根节点的值来决定遍历策略时。

#### 中序遍历

- **遍历顺序**：左子树 -> 根节点 -> 右子树
- **特点**：首先递归地遍历左子树，然后访问根节点，最后是右子树。
- **适用场景**：
    - 对于二叉搜索树（BST），中序遍历可以生成有序序列。
    - 需要按照树的逻辑顺序（例如，字典序）访问节点时。
    - 进行树的排序操作。

#### 后序遍历

- **遍历顺序**：左子树 -> 右子树 -> 根节点
- **特点**：首先递归地遍历左子树，然后是右子树，最后访问根节点。
- **适用场景**：
    - 需要先访问所有子节点再访问根节点的场景，例如在树的销毁或清理过程中。
    - 进行树的剪枝操作，例如在决策树中。
    - 需要在访问节点之前先收集子树信息时。

#### 如何分辨：

- **前序遍历**：先看到根节点，然后是左子树，最后是右子树。
- **中序遍历**：先看到左子树，然后是根节点，最后是右子树。
- **后序遍历**：先看到左子树，然后是右子树，最后是根节点。

#### 记忆技巧：

- 想象你在树中行走，前序遍历就像是你先走到树的中心（根节点），然后向左走（左子树），最后向右走（右子树）。
- 中序遍历就像是你先向左走（左子树），然后走到中心（根节点），最后向右走（右子树）。
- 后序遍历就像是你先向左走（左子树），然后向右走（右子树），最后走到中心（根节点）。

## 功能树

正如开头所言 树结构的存在是为了同时保留数组和链表的优点: 高速排序 高速查找 高速删减.而二叉树又对应了一种非常有用的优化思维: 二分求解.  定义好特定的增删节点方式, 或者是动态的维护好二叉树的形态, 往往能够将时间复杂度提高至对数级别. 

### 二叉搜索树(二分搜索)

- 特性：对于BST中的每个节点，其左子树上的所有节点的值都小于该节点的值，其右子树上的所有节点的值都大于该节点的值。
- 应用：高效的数据查找、插入和删除操作。

只需要在插入数据时判断好作为谁的子节点插入即可.
(可以手搓一下 对递归的理解很有帮助)

```c++
#include <iostream>

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BinarySearchTree {
public:
    BinarySearchTree() : root(nullptr) {}

    // 插入节点
    void insert(int val) {
        root = insertNode(root, val);
    }

    // 查找节点
    TreeNode* search(int val) {
        return searchNode(root, val);
    }

    // 删除节点
    void remove(int val) {
        root = deleteNode(root, val);
    }

private:
    TreeNode* root;

    // 辅助函数：插入节点
    TreeNode* insertNode(TreeNode* node, int val) {
        if (node == nullptr) {
            return new TreeNode(val);
        }
        if (val < node->val) {
            node->left = insertNode(node->left, val);
        } else if (val > node->val) {
            node->right = insertNode(node->right, val);
        }
        return node;
    }

    // 辅助函数：查找节点
    TreeNode* searchNode(TreeNode* node, int val) {
        if (node == nullptr || node->val == val) {
            return node;
        }
        if (val < node->val) {
            return searchNode(node->left, val);
        } else {
            return searchNode(node->right, val);
        }
    }

    // 辅助函数：删除节点
    TreeNode* deleteNode(TreeNode* node, int val) {
        if (!node) return nullptr;
        if (val < node->val) {
            node->left = deleteNode(node->left, val);
        } else if (val > node->val) {
            node->right = deleteNode(node->right, val);
        } else {
            // 情况1: 没有右子节点
            if (!node->right) {
                TreeNode* temp = node->left;
                delete node;
                return temp;
            }
            // 情况2: 没有左子节点
            if (!node->left) {
                TreeNode* temp = node->right;
                delete node;
                return temp;
            }
            // 情况3: 既有左子节点又有右子节点
            TreeNode* temp = minValueNode(node->right);
            node->val = temp->val;
            node->right = deleteNode(node->right, temp->val);
        }
        return node;
    }

    // 找到二叉搜索树中的最小值节点
    TreeNode* minValueNode(TreeNode* node) {
        TreeNode* current = node;
        while (current && current->left) {
            current = current->left;
        }
        return current;
    }
};

int main() {
    BinarySearchTree bst;
    bst.insert(50);
    bst.insert(30);
    bst.insert(20);
    bst.insert(40);
    bst.insert(70);
    bst.insert(60);
    bst.insert(80);

    TreeNode* result = bst.search(60);
    if (result) {
        std::cout << "Found: " << result->val << std::endl;
    } else {
        std::cout << "Not found." << std::endl;
    }

    bst.remove(20);
    result = bst.search(20);
    if (result) {
        std::cout << "Found: " << result->val << std::endl;
    } else {
        std::cout << "Not found." << std::endl;
    }

    return 0;
}
```

这种简单的增删逻辑在最差情况下会将整棵树退化成链表, 使得查找退化为线性复杂度.我们可以使用给树动态"修枝"的方式(实际上是旋转)来实现平衡二叉搜索树, 来保持操作的对数时间复杂度.

### 红黑树

- [ ] todo: 红黑树