

## 由浅入深易

### 买卖股票的最佳时机：
   假设你有一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。设计一个算法来计算你所能获得的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（即你必须在再次购买前出售掉之前的股票）。

**变式一: 只能进行一次交易**

本质上是一次遍历的过程中维护最小值和最小值右侧的最大值. 注意直接使用max-min可能有max在min左侧的情况, 故需要在遍历过程中保留最大利润, 仅当新找到的max_new-min_new大于原有利润值时更新. 这就是最简单的动态规划模型, 使用一个一维数组就可以实现.
具体的状态转移为:第i天的最大利润仅当prices[i]-min_price大于i-1天的最大利润时更新

```c++
int maxProfitOnceTransaction(const std::vector<int>& prices) {
    if (prices.empty()) return 0; // 如果没有价格数据，直接返回0

    int min_price = INT_MAX; // 初始化为一个很大的数，表示迄今为止的最低价格
    int max_profit = 0; // 初始化最大利润为0

    for (int i = 0; i < prices.size(); ++i) {
        // 每次循环更新最低价格
        if (prices[i] < min_price) {
            min_price = prices[i];
        }
        // 计算如果今天卖出的利润，并更新最大利润
        int current_profit = prices[i] - min_price;
        if (current_profit > max_profit) {
            max_profit = current_profit;
        }
    }

    return max_profit;
}
```

**变式二: 能够进行任意多次的交易**

- **状态定义**：定义 `dp[i][0]` 表示到第 `i` 天为止不持有股票的最大利润，`dp[i][1]` 表示持有股票的最大利润。
- **状态转移**：
    - `dp[i][0]` 可以从未持有股票的状态转移而来（即前一天也不持有），或者从卖出股票的状态转移而来（即前一天持有股票）。
    - `dp[i][1]` 可以从未持有股票的状态买入股票转移而来（即前一天不持有），或者保持持有股票（即前一天也持有）。

 正确的状态转移方程示例：

```c++
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]); // 卖出或保持不持有 
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]); // 买入或保持持有
```

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) return 0;
        int sold = 0, hold = -prices[0]; // 初始化
        for (int i = 1; i < prices.size(); ++i) {
            int prev_sold = sold;
            int prev_hold = hold;
            hold = max(prev_hold, prev_sold - prices[i]); // 决定是否买入
            sold = max(prev_sold, prev_hold + prices[i]); // 决定是否卖出
        }
        return sold; // 返回不持有股票时的最大利润
    }
};
```

**变式三: 能够进行至多k次交易**

- [ ] todo...



### 附录
#### leetcode出处

在 LeetCode 上，买卖股票的问题是一个常见的面试题目，它以不同的变体出现，主要考察对贪心思想和动态规划的理解和应用。以下是一些 LeetCode 上关于买卖股票的最佳时机问题的汇总：

1. **121. 买卖股票的最佳时机**：只允许完成一笔交易（即买入和卖出一支股票一次），目标是计算所能获取的最大利润。这个问题可以通过一次遍历解决，使用贪心算法。

2. **122. 买卖股票的最佳时机 II**：允许完成多次交易，但不能同时参与多笔交易。可以通过动态规划解决，使用两个状态：`dp[i][0]` 表示第 `i` 天不持有股票的最大利润，`dp[i][1]` 表示持有股票的最大利润。

3. **123. 买卖股票的最佳时机 III**：允许最多完成两笔交易。这个问题可以通过扩展 122 题的动态规划解法来解决，增加状态来记录已完成的交易次数。

4. **188. 买卖股票的最佳时机 IV**：允许最多完成 `k` 笔交易。这个问题可以通过三维动态规划解决，增加一个维度来记录交易次数。

5. **309. 最佳买卖股票时机含冷冻期**：在卖出股票后，有一个冷冻期，在此期间不能买入股票。这个问题可以通过动态规划解决，增加一个状态来记录是否处于冷冻期。

6. **714. 买卖股票的最佳时机含手续费**：在交易时需要支付手续费。这个问题可以通过修改 122 题的动态规划解法来解决，计入手续费的影响。

这些问题的解法通常涉及到贪心算法和动态规划，需要对股票价格数组进行一次或多次遍历，并在每次遍历中做出买卖决策以最大化利润。根据题目的不同，可能需要考虑交易次数限制、冷冻期或手续费等因素。

#### 参考文献
https://www.cnblogs.com/kkbill/p/13259056.html
