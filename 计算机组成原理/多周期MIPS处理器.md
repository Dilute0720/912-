## 回忆: 单周期划分为五阶段

不妨回忆一个单周期处理器中的简单例子: 尽管一切都发生在一个时钟周期内, 但我们依旧可以考虑分成以下几步来执行R型指令(其他指令类似):

1. 从指令寄存器取出指令, PC自增
2. 从寄存器堆中读出寄存器的值, 同时主控单元计算出各个控制信号的状态
3. ALU根据控制信号确定合适的计算功能, 进行计算操作
4. 将结果写回寄存器堆

在单周期处理器中, 数据通路上靠后的部分会长时间处于待定(未知)的状态, 直到前序的过程输出稳定后才会进行后续步骤的执行, 这样导致CPU的一个时钟周期中有很长一段时间硬件都处于等待数据稳定的状态. 我们可以很容易想到提高CPU的时钟频率, 让每一个更短的时钟周期内只执行某一个步骤. 甚至可以进一步优化为流水线的结构.

正如我们最初提到的例子一般, 每一个指令都可以更普遍的划分为: IF(取指) ID(指令译码) EX(指令执行) MEM(存储访问) WB(写回)

![[五阶段划分的指令.png]]

## 流水线构想

### 洗衣房的例子

洗衣房的流水线常常在各大教材中作为教学处理器流水线的案例, 我们这里也可以对其稍做分析, 对应于MIPS指令的五个阶段:

1. **接收区（IF - 取指）**：衣物被送到这里，进行初步的分类和检查，类似于处理器中的取指令阶段。
2. **预处理区（ID - 指令译码）**：根据衣物类型进行预处理，如去除污渍、分拣等，这类似于处理器中的指令译码阶段，确定执行哪种操作。
3. **洗涤区（EX - 指令执行）**：使用不同的洗涤程序和水温，确保衣物被正确清洗，这相当于处理器中的执行阶段。
4. **烘干区（MEM - 存储访问）**：根据衣物材质选择合适的烘干方式，类似于处理器中的存储访问阶段，处理数据存储和读取。(~~有点强行解释了嗷~~)
5. **折叠区（WB - 写回）**：将衣物折叠整齐，准备打包，这类似于处理器中的写回阶段，将最终结果写入寄存器或存储器。

理想的洗衣房当然可以不阻塞的执行这样的洗衣任务, 从而将效率提升至接近五倍, 但对于计算机指令来说, 可能会有一些小小的意外发生.

### 流水线上的意外

接下来这一部分我们会对流水线冒险稍作介绍, 但是如何从硬件层面应对它, 我们将会在后文中延迟介绍.

#### 结构冒险: Structural Hazard

考虑这样的一个例子:![[指令流水线_01.png]]

如果我们紧接着加入第四条指令, 那么在600~800ns的时间里第一条指令还在进行存储器的数据访问, 而第四条指令的取值单元已经开始向存储器发送取指令的信号, 传入PC地址, 这样就会导致硬件结构上的冲突, 称为结构冒险.

一种明显的解决方案是给PC和ALU输出分开设立两个和存储器通信的端口, 使得取指令和读取数据同步进行.

#### 数据冒险: Data Hazard

一条指令执行完毕通常需要5个周期才能将计算结果写回寄存器, 而倘若连续的R型指令对同一寄存器的值进行计算, 则每次下一条R型指令必须等待前一条R型指令执行完成才能继续执行, 这种情况下流水线已经几乎退化为单周期处理器了. 而事实上这种连续的原地运算是很常见的行为, 我们必须思考如何解决这一困境

仔细思考可以发现, 对需要连续使用写回寄存器的值的情况下, 我们或许并不需要等待上一条指令执行到第5WB, 而是直接在第3步ALU运算结束之后直接将数据的值拿出来作为下一条指令的ALU输入. 这种解决方案我们称作 **前推forwarding** 或 **旁路bypassing**.![[数据冒险_bypassing.png]]

#### 控制冒险: Control Hazard

指令集中有一类特殊的指令, 它会改变指令执行的次序, 在计算结果得出之前处理器根本无法得知接下来到底需要执行哪一条指令——这就是分支指令.

我们并没有一个完美的方案提前获知分支指令会把我们导向到哪里去, 但是我们也不会坐以待毙每逢分支则让整个流水线罢工. 既然无法实现完美, 我们就不追求完美, 先猜测结果是什么再说, 这就是计算机伟大思想之 **预测**.

当预测正确(分支未发生)时, 流水线会全速的执行, 只有当分支发生是流水线才会阻塞. 当然预测错误也有一些代价, 这段时间里被误读入的数据和错误更改的pc需要单独的处理. 

### 流水线数据通路

