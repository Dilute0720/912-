## 回忆: 单周期划分为五阶段

不妨回忆一个单周期处理器中的简单例子: 尽管一切都发生在一个时钟周期内, 但我们依旧可以考虑分成以下几步来执行R型指令(其他指令类似):

1. 从指令寄存器取出指令, PC自增
2. 从寄存器堆中读出寄存器的值, 同时主控单元计算出各个控制信号的状态
3. ALU根据控制信号确定合适的计算功能, 进行计算操作
4. 将结果写回寄存器堆

在单周期处理器中, 数据通路上靠后的部分会长时间处于待定(未知)的状态, 直到前序的过程输出稳定后才会进行后续步骤的执行, 这样导致CPU的一个时钟周期中有很长一段时间硬件都处于等待数据稳定的状态. 我们可以很容易想到提高CPU的时钟频率, 让每一个更短的时钟周期内只执行某一个步骤. 甚至可以进一步优化为流水线的结构.

正如我们最初提到的例子一般, 每一个指令都可以更普遍的划分为: IF(取指) ID(指令译码) EX(指令执行) MEM(存储访问) WB(写回)

## 流水线构想

### 洗衣房的例子

洗衣房的流水线常常在各大教材中作为教学处理器流水线的案例, 我们这里也可以对其稍做分析, 对应于MIPS指令的五个阶段:

1. **接收区（IF - 取指）**：衣物被送到这里，进行初步的分类和检查，类似于处理器中的取指令阶段。
2. **预处理区（ID - 指令译码）**：根据衣物类型进行预处理，如去除污渍、分拣等，这类似于处理器中的指令译码阶段，确定执行哪种操作。
3. **洗涤区（EX - 指令执行）**：使用不同的洗涤程序和水温，确保衣物被正确清洗，这相当于处理器中的执行阶段。
4. **烘干区（MEM - 存储访问）**：根据衣物材质选择合适的烘干方式，类似于处理器中的存储访问阶段，处理数据存储和读取。(~~有点强行解释了嗷~~)
5. **折叠区（WB - 写回）**：将衣物折叠整齐，准备打包，这类似于处理器中的写回阶段，将最终结果写入寄存器或存储器。

理想的洗衣房当然可以不阻塞的执行这样的洗衣任务, 从而将效率提升至接近五倍, 但对于计算机指令来说, 可能会有一些小小的意外发生.

### 流水线上的意外

接下来这一部分我们会对流水线冒险稍作介绍, 但是如何从硬件层面应对它, 我们将会在后文中延迟介绍.

#### 结构冒险: Structural Hazard

考虑这样的一个例子:![[结构冒险_01.png]]

如果我们紧接着加入第四条指令, 那么在600~800ns的时间里第一条指令还在进行存储器的数据访问, 而第四条指令的取值单元已经开始向存储器发送取指令的信号, 传入PC地址, 这样就会导致硬件结构上的冲突, 称为结构冒险.

一种明显的解决方案是给PC和ALU输出分开设立两个和存储器通信的端口, 使得取指令和读取数据同步进行. 也可以直接将指令存储器和数据存储器分隔开来进行处理,这种架构通常需要更多的硬件资源，因为它需要两个独立的存储系统. 前者被称作存储器的**冯·诺伊曼架构**, 后者被称为**哈佛架构**. 现代的CPU通常采用冯·诺依曼架构，但通过使用高速缓存（Cache）和其他技术来减少指令和数据访问的冲突。

#### 数据冒险: Data Hazard

一条指令执行完毕通常需要5个周期才能将计算结果写回寄存器, 而倘若连续的R型指令对同一寄存器的值进行计算, 则每次下一条R型指令必须等待前一条R型指令执行完成才能继续执行, 这种情况下流水线已经几乎退化为单周期处理器了. 而事实上这种连续的R型运算是很常见的行为, 我们必须思考如何解决这一困境

仔细思考可以发现, 对需要连续使用写回寄存器的值的情况下, 我们或许并不需要等待上一条指令执行到第5WB, 而是直接在第3步ALU运算结束之后直接将数据的值拿出来作为下一条指令的ALU输入. 这种解决方案我们称作 **前推forwarding** 或 **旁路bypassing**.![[数据冒险_bypassing.png]]

#### 控制冒险: Control Hazard

指令集中有一类特殊的指令, 它会改变指令执行的次序, 在计算结果得出之前处理器根本无法得知接下来到底需要执行哪一条指令——这就是分支指令.

我们并没有一个完美的方案提前获知分支指令会把我们导向到哪里去, 但是我们也不会坐以待毙每逢分支则让整个流水线罢工. 既然无法实现完美, 我们就不追求完美, 先猜测结果是什么再说, 这就是计算机伟大思想之 **预测**.

当预测正确(分支未发生)时, 流水线会全速的执行, 只有当分支发生是流水线才会阻塞. 当然预测错误也有一些代价, 这段时间里被误读入的数据和错误更改的pc需要单独的处理. 

> 有关数据冒险和控制冒险的处理我们将会在后文中得知

---

### 流水线数据通路

![[流水线时间轴.png]]

上图是一个流水线指令执行过程示意图, 像这样流水线执行三条指令的情况, 最直观的解决方案是给每个硬件设计三倍数量的端口, 采用类似"轮询"的方式让数据依次访问端口, 这样的直接后果是成本提升, 控制信号过于复杂. 如果我们共用数据通路, 又可能会发生后一条指令的输出干扰前一条指令的情况. 所以我们需要使用流水线寄存器来分割不同阶段, 确保每个阶段可以独立工作，不受其他阶段的干扰。

![[五阶段划分方案.png]]

上图是我们所设计的单周期处理器的数据通路图, 在每一个clk(时钟周期)中信号自左至右依次改变. 要将其改成5个阶段的流水线, 我们需要在上图中四个虚线处加入流水线寄存器. 

流水线寄存器中存放的内容为指令内容+前一部分硬件生成的结果和信号线. 每个时钟周期只需要同步更新至每一个流水线寄存器即可.

![[流水线寄存器.png]]


#### IF/ID寄存器

取指令阶段, PC自增并写回PC寄存器以备下一个clk使用. 此时尚不知道待执行的指令具体是什么, 有可能使用当前的PC地址(比如分支/跳转指令), 因而我们要将PC+4这个地址和PC地址对应的32位指令一并存入IF/ID寄存器.

```verilog
module IF_ID_Reg(
	input wire clk,
	input wire reset,
	input wire pc[31:0],
	input wire next_pc[31:0],
	output reg instr[31:0],
	output reg pc_out[31:0],
)
```

#### ID/EX寄存器

指令译码后, 对R型指令我们会读取两个寄存器的值, 对I型指令我们需要16位符号扩展后的32位数, 同时IF/ID寄存器中留下的PC+4的值我们依旧要保留下来, 以备后续阶段使用.

---

Q?:为什么要保留呢? 为什么要给IF/ID寄存器多设定32位而不能直接把PC+4放到ID/EX寄存器?(既然ID阶段并没有使用这个地址)

A: 这是为了保证数据自左向右流动的同步性, 同时也是由于ID阶段完成后需要适应接下来下一条指令的读入(尽管此时还并不能确定PC+4读入的指令就是正确应该执行的指令).

---

```verilog
module ID_EX_Reg(
	input wire clk,
	input wire reset,
	input wire pc[31:0],
	input wire RsData[31:0],
	input wire RtData[31:0],
	input wire ImmExterned[31:0], 
	output reg BaseAddr[31:0],
	output reg Alu_input_a[31:0],
	output reg Alu_input_b[31:0],
	output reg ImmExterned_o[31:0],
	input wire controls[?]
)
```

#### EX/MEM寄存器

和上述的分析过程非常类似, EX_MEM寄存器要保留ALU的计算结果(EX阶段产出)和Store Word指令需要传递的寄存器数据RsData. 同时在EX阶段计算完毕的地址计算结果可以直接从EX/MEM寄存器跳过MEM和WB阶段直接写回PC.

```verilog
module EX_MEM_Reg(
	input wire clk,
	input wire reset,
	input wire Addr_in[31:0],
	input wire zero,
	input wire ALU_ans[31:0],
	input wire RsData_in[31:0],
	output reg Addr_out[31:0],
	output reg zero_out,
	output reg ALU_out[31:0],
	output reg Data_out[31:0],
	input wire controls[?]
)
```

#### MEM/WB寄存器

这部分的寄存器主要存储LoadWord指令从存储器中取出来的值以及ALU运算后等待写回寄存器的结果. 由于写回只能一次写回一个数据, 我们可以在这段寄存器后集成一个多路选择器, 当当前指令为LoadWord指令时输出MEM_data, 否则一律输出ALU_data.

```verilog
module MEM_WB_Reg(
	input wire clk,
	input wire reset,
	input wire MEM_data_in[31:0],
	input wire ALU_data_in[31:0],
	output reg WriteBack_data[31:0],
	input wire control[?]
)
```

需要写回寄存器的编号在哪里呢? 对于`lw $t0 offset(base_addr)`指令来说, 待写回的寄存器编号应该在ID阶段就生成了, 所以我们需要将ID阶段的**5位寄存器地址**放入后续的流水线寄存器依次传递至MEM/WB寄存器.

---

### 流水线控制信号

IF和ID阶段所做的PC自增和指令译码工作是每一条指令都需要完成的内容, 直接让它随着时钟周期进行即可, 具体的控制体现在EX,MEM,WB阶段.

EX阶段是对ALU执行的控制, 控制信号有ALU输入选择`ALUSrc`, ALU运算选择`ALUop[1:0]`, R型指令和I型指令需要写回到不同的寄存器, 需要`RegDest`来选择\$Rt还是\$Rd.

MEM阶段有控制存储器读写使能的`MemWrite`和`MemRead`两个存储器控制信号, 另外的还负责有分支指令`beq`需要根据ALU的zero输出(这个输出已经存放在EX/MEM寄存器中了)和分支指令信号`branch`的与信号共同选择下一条指令的地址.

---

> Q: 一条分支指令经过IF/ID/EX三个阶段后才会被判断是否分支, 这段时间流水线又启动了接下来的两条指令取指, 如果分支确实发生了如何回退这两个已经执行了前两阶段的指令呢?

> A: 这正是我们一开始介绍的流水线可能出现的问题: 控制冒险. 计算机采用先假设后求证的思想解决问题, 如果假设错误了, 可以让流水线回滚(Flushing), 我们稍后就会讨论这个问题.
---

WB阶段的控制信号则是寄存器堆使能信号`RegWrite`和LoadWord指令对应的选择存储器输入的信号`MemtoReg`

有了这些基本的控制信号, 我们如何让控制信号也随着流水线一起流动呢? 同样利用流水线寄存器即可, 在指令译码的阶段加入控制器`Controller`生成控制信号的部分, 并将所有控制信号加入流水线寄存器依次传播即可.

最后的完整数据通路图如下:![[流水线完整数据通路.png]]

### 数据冒险的解决方案

#### 旁路bypassing

旁路是一个非常非常非常巧妙的设计, 它是如此的精巧以至于我不得不先交出这张图再做说明![[数据冒险_旁路解决方案.png]]

旁路做了一个什么事情呢? ALU的输入数据可能很普通的**来自寄存器堆**, 但也可能**来自之前指令的ALU输出**, 也可能**来自之前指令待写回寄存器的数据**. 具体如何选择, 则是我们需要着重思考的问题.

我们需要对数据冒险的产生进行一个分类. 本质上来说, IF和ID阶段每个指令都是同样的执行, EX阶段开始有所不同. 如果一条指令的EX阶段使用了上两条指令WB阶段才能写回寄存器的数据, 则会发生数据冒险. 为何是上两条呢?因为冒险可能在MEM和WB两个阶段都发生. 再根据指令使用的寄存器是Rs还是Rt可以再次细分如下四类:

等号左边为尚未写回的寄存器编号, 右边为即将输入寄存器的寄存器编号.
- 1a. EX/MEM.RegisterRd = ID/EX.RegisterRs
- 1b. EX/MEM.RegisterRd = ID/EX.RegisterRt
- 2a. MEM/WB.RegisterRd = ID/EX.RegisterRs
- 2b. MEM/WB.RegisterRd = ID/EX.RegisterRt

因此我们可以如下设计旁路多选器的控制信号:

| 多选器控制信号        | 数据源    | 解释                            |
| -------------- | ------ | ----------------------------- |
| ForwardA=2'b00 | ID/EX  | ALU_input_a为正常来自寄存器堆的操作数      |
| ForwardA=2'b10 | EX/MEM | ALU_input_a为上一个ALU运算的结果旁路     |
| ForwardA=2'b01 | MEM/WB | ALU_input_a为存储器或两次前ALU运算的结果旁路 |
| ForwardB=2'b00 | ID/EX  | ALU_input_b为正常来自寄存器堆的操作数      |
| ForwardB=2'b10 | EX/MEM | ALU_input_b为上一个ALU运算的结果旁路     |
| ForwardB=2'b01 | MEM/WB | ALU_input_b为存储器或两次前ALU运算的结果旁路 |

控制信号应该由当前阶段的指令信息以及后两个阶段(前两条指令)的信息共同决定.
```verilog
//1a类型冒险,上一条指令需要写回寄存器堆且要写回的目标寄存器就是下一条指令的Rs输入
if(EX_MEM.RegWrite == 1'b1 &&
   EX_MEM.RegisterRd != 1'b0 &&
   EX_MEM.RegisterRd == ID_EX.RegisterRs)
   ForwardA = 2'b10;

//1b类型冒险,上一条指令需要写回寄存器堆且要写回的目标寄存器就是下一条指令的Rt输入
if(EX_MEM.RegWrite == 1'b1 &&
   EX_MEM.RegisterRd != 1'b0 &&
   EX_MEM.RegisterRd == ID_EX.RegisterRt)
   ForwardB = 2'b10;

//2a类型冒险, 上上条指令的写回的目标寄存器是下一条指令的Rs输入
if(MEM_WB.RegWrite == 1'b1 &&
  MEM_WB.RegisterRd != 1'b0 &&
  MEM_WB.RegisterRd == ID_EX.RegisterRs)
  ForwardA = 2'b01;
  
//2b类型冒险, 上上条指令的写回的目标寄存器是下一条指令的Rs输入
if(MEM_WB.RegWrite == 1'b1 &&
  MEM_WB.RegisterRd != 1'b0 &&
  MEM_WB.RegisterRd == ID_EX.RegisterRt)
  ForwardB = 2'b01;
```

以上四种情况都只考虑了当前待运算指令和上一条或者上上条指令可能发生的数据冒险可能, 事实上如果有一个寄存器的值一直在原地操作(比如常见的while(i++)), 可能会有1类型和2类型冒险同时存在的情况. 这种情况下我们应该拿出EX/MEM寄存器中的结果而不是MEM/WB寄存器的结果, 因为这个时候刚刚EX阶段计算得出的才是最新的寄存器结果.

因此我们可以对2类型冒险增加一点额外的控制: 当类型1冒险发生时不允许类型二的控制信号改变, 将控制信号改成如下即可:

```verilog
//2类型冒险
if(MEM_WB.RegWrite == 1'b1 &&
  MEM_WB.RegisterRd != 1'b0 &&
  !(EX_MEM.RegWrite == 1'b1 &&
   EX_MEM.RegisterRd != 1'b0 &&
   EX_MEM.RegisterRd == ID_EX.RegisterRs)&&
  MEM_WB.RegisterRd == ID_EX.RegisterRs)
  ForwardA = 2'b01;
```

#### 阻塞

旁路是一种非常巧妙的技巧, 它仅仅是多了一些控制信号和寄存器的开销, 可以让流水线能够几乎不停滞的进行. 但是有一些特殊的指令组合会让旁路也无法解决问题: 当一条指令试图读取一个由前一条LoadWord指令读入的寄存器时, 我们不得不等待`lw`指令执行完成MEM阶段才可能得知寄存器的值应该是什么. 这种情况下我们就不得不损害一部分流水线的效率, 让流水线暂时阻塞一阵子.

如何判断阻塞是否需要发生呢? 这需要阻塞冒险检测单元: 当译码(ID)时发现这条指令是load指令, 立刻检测IF阶段取的指令是否使用到了load指令的目标寄存器, 如果是则让流水线停滞一回合.

```verilog
if(ID_EX.MemRead == 1'b1 &&
	  ((ID_EX.RegisterRt == IF_ID.RegisterRs) || ID_EX.RegisterRt == IF_ID.RegisterRt)  
  )
  stall the pipeline;
```

如何让流水线停滞一回合而不产生其他的影响呢? 这就需要 **空指令** 了. 空指令并不需要在流水线中走过每个阶段, 因为我们在IF取完指令之后才会发现需要在接下来的四个阶段中停滞一下, 就像流水线中突然多出了一个"气泡". 我们仅仅需要在ID/EX流水线寄存器的所有控制信号都置零, 这样所有的寄存器和存储器都不会进行读写操作. 这样的空指令也可以通过汇编显式的设计, 在一些汇编编译器中支持名为`nop`的指令,这就是空指令.

### 控制冒险的解决方案

控制冒险出现的频率比起数据冒险要少得多, 而且与使用旁路和阻塞就能有效解决的数据冒险不同, 至今我们仍然没有非常好的方案完美的解决控制冒险.

#### 预测: 假定分支不执行

采用阻塞直到分支判断完毕来处理控制冒险的方案实在是太慢, 我们可以假设分支不发生, 并继续执行顺序的指令流. 如果分支发生了, 就丢弃已经读取并译码的指令, 并跳转至分支指令处执行.

丢弃指令的代价很小, 只需要将最初的控制信号和已经在流水线上的控制信号置零即可. 这种操作也叫做将流水线IF, ID, EX级的指令都擦除.

#### 笨鸟先飞: 缩短分支的判断时间

很多分支指令并不需要很复杂的逻辑, 大多只是简单的相等. 既然流水线的周期依旧取决于最慢子周期的限制, 我们可以在用时较短的译码阶段加入一些逻辑门提前运算, 这样当我们预测失败需要擦除指令是就可以只擦除后一条尚处于IF阶段的指令了.

### 异常与中断

尽管我们对我们所设计的流水线有着很强的信心, 精心设计了数据通路和冒险管理措施, 但是我们依旧需要对异常的管理. **异常(exception)** 也可以称为**中断(interrupt)** ,如果非要给他两一个区别, 那么或许中断往往表示的是来自处理器外部的打断而非处理器内部的数据溢出等问题. 通常来说我们可以把外部的I/O设备请求称作中断, 程序进行OS调用导致CPU停止, 解码遇到未定义的指令等情况都称作异常.

MIPS体系结构中处理异常的解决方案是保存指令出错的地址, 然后将控制权转交给OS的特定地址去处理. 这个保存出错地址的寄存器叫 **异常程序寄存器(Exception  Program Counter, EPC)** .

对流水线而言, 异常发生之后除了保存当前地址以外, 还需要擦除后续的新信号. 这与控制冒险的解决方案非常的类似了.

## 后记 

总算写完了, 写的很慢. 尽管力求清楚, 但是感觉也有点力不从心 , 没法让阅读这篇文章的人就能醍醐灌顶. 这甚至不是自己编写内容而仅仅是对着书本记下自己的理解和笔记, 可想而知编写教材是一件多么困难而值得敬佩的事情了.

还有一些高级的内容包括指令并行和静态多发射处理器等等内容没有涉及, 已经不在912考研范围内了. 感兴趣的可以去自己了解一下. 

最后的最后, 贴一张流水线处理器的全家福.纪念被吓坏了半个学期的大三数逻课.![[流水线全家福.png]]