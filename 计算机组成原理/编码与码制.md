## 0. 原码: 数的直观二进制表示

假定一种数据类型叫8_bit_int, 合法取值在`0000 0000 ~ 1111 1111`之间
对unsigned_8_bit_int, 直接转换成十进制即可

对signed_8_bit_int, 我们规定第一个数据位为符号为, 0表示正, 1表示负;
从而我们有`0000 0000 ~ 0111 1111`表示0~127,`1000 0000 ~ 1111 1111`表示0~-127.
这种直观的二进制表示方案我们将其称作数的**原码**表示.

这样的表示方案有一处非常不和谐的地方, 0作为 +0 和 -0 出现了两次. 这样会导致一个数加上0的值并不确定,为了解决这个问题, 我们需要慎重考虑数在计算机中应该以何种二进制编码存储. 这需要从最基本的加减法说起.

## 1. 加法与减法

### 电路实现

 设计一个全加器, 要实现的最基本功能是输入A+B得到值Sum和进位信息C. 为了能够让多个全加器串联形成多位加法器, 再补充进位输入$C_{i-1}$ .其真值表如下.

| 输入   | 输入  | 输入  | 输出  | 输出  |
| ---- | --- | --- | --- | --- |
| Ci-1 | Ai  | Bi  | Si  | Ci  |
| 0    | 0   | 0   | 0   | 0   |
| 0    | 0   | 1   | 1   | 0   |
| 0    | 1   | 0   | 1   | 0   |
| 0    | 1   | 1   | 0   | 1   |
| 1    | 0   | 0   | 1   | 0   |
| 1    | 0   | 1   | 0   | 1   |
| 1    | 1   | 0   | 0   | 1   |
| 1    | 1   | 1   | 1   | 1   |

其表达式为:

![](https://bkimg.cdn.bcebos.com/formula/0d2dfecff9f0c6cabb8177ae1c3c8b75.svg)

这样看来, 只需要几个简单的与门非门异或门就可以构建好全加器, 加法器只不过在其基础上做了一个拼积木的游戏, **加法器搞定了, 减法器又如何实现呢?**

### 减法: 正难则反

#### 引子: 12进制的时钟

如果说有一个数据类型, 只能存储0~12之间的数,  用于记录现实生活中的小时数, 我们不称之为大小为12的数域. 那么我们显然可以有一套基于这个时钟的运算法则. 

```时钟域
在周期为12的时钟域下, 如下的加法和减法是很自然的
2 + 3 =      5
5 + 7 = 12 = 0
7 + 8 = 15 = 3

7 - 3 =      4
12 - 5 =     7
0 - 5 = -5 = 7
2 - 3 = -1 = 11

我们还可以发现一个数加上12还是它本身,那么根据这一点我们就可以把减法转换成加法来进行:

0 - 5 = 0 + (12 - 5) = 7
2 - 3 = 2 + (12 - 3) = 2 + 9 = 11

在这样的例子中, -5和7其实是一样的, -3和9其实是一样的.这样的转换使得使用加法就能处理减法,好处有二:
1. 节省了减法器的电路空间
2. 避免了减法结果为数域以外的值

同时我们可以注意到,对于7-3这样的常规减法一样可以这样处理:
7 - 3 = 7 + 12 - 3 = 12 + 4 = 4
其中上溢的12并不需要我们自行处理, 直接在表盘上转一整圈即可, 在二进制表示的数字中, 超出上限的数我们也不需要特殊处理, 使其自然上溢即可.
```

回到8_bit_int的例子, 这又何尝不是一个大小为256的数域呢?如果我们将0~127用来代表正数部分, 而对一个负数`-value`, 则可以用256-value来代表, **value的取值可以取1~128**, 从而**对应到二进制数上128~255的部分**, 而这正是计算机存储有符号整数的方式. 

### 补码: 重回减法

看起来很不错的一个用正数来替代负数, 用加法替代减法的方案, 稍作思考就可以发现有一个重大问题: 256-value值不是又回到减法上了吗? 

诚然如此, 但是这时候二进制计数法展现出了它独特的优势, 这一减法运算在二进制上可以表现为 **符号位不变, 数值位取反, 最后加一**. 让我们来看看吧.

```
	1 0000 0000//256
   -  0010 1011//value
   ------------//等价为255 - value + 1 
      1111 1111
   -  0010 1011 + 1
   ------------//按位取反, 1变0, 0变1;
      1101 0100 + 1 = 1101 0101//符号位
```

发现了吗, 对负数来说, 我们设计了这样的一种二进制表示, 使用1作为符号位不变, **在其原码的基础上, 对数值位按位取反加一**, 将这种表示方案称作二进制数的 **补码** 表示.

显然, 补码既然是为了表示负数而生, **正整数的补码并不需要特殊的处理, 就按原码行事**即可.
\
### 反码: 应试的产物

这么说或许有些许冒昧, 但是反码作为常规教材中获得补码的中间产物, 我并不觉得这是一个需要专门设计出来的二进制码. 它刻意的将 **符号位不变 按位取反** 这一操作单独命名, 而不讲解其中缘由, 多少是有所失败的. 反码可以有它存在的意义, 但并**不适合和原码与补码的问题相提并论**. 